import customtkinter as ctk
import requests
import zipfile
import io
import os
import threading
import platform
import subprocess
import logging
import urllib3
import shutil
import time

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

if platform.system() != "Windows":
    raise SystemExit("Windows only")

APP_NAME = "Infinite Dash Runner"
VERSION_URL = "https://raw.githubusercontent.com/FahrettinPasha/Infinite-Dash-Runner-Pygame/main/version.json"
FALLBACK_ZIP = "https://github.com/FahrettinPasha/Infinite-Dash-Runner-Pygame/archive/refs/heads/main.zip"

BASE_DIR = os.path.join(os.getenv("APPDATA"), "PashaGames", "InfiniteDash")
GAME_DIR = os.path.join(BASE_DIR, "game")
VERSION_FILE = os.path.join(BASE_DIR, "version.txt")
LOG_FILE = os.path.join(BASE_DIR, "install.log")

os.makedirs(GAME_DIR, exist_ok=True)

logging.basicConfig(
    filename=LOG_FILE,
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

class Launcher(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title(APP_NAME)
        self.geometry("600x550")
        self.resizable(False, False)

        ctk.CTkLabel(self, text=APP_NAME, font=("Arial", 26, "bold")).pack(pady=10)

        # Scrollable Text widget
        self.log_text = ctk.CTkTextbox(self, width=560, height=380)
        self.log_text.pack(padx=10, pady=10)
        self.log_text.configure(state="disabled")  # sadece yazma

        self.start_btn = ctk.CTkButton(self, text="Başlat", width=200, command=self.start)
        self.start_btn.pack(pady=5)

        self.stop_btn = ctk.CTkButton(self, text="Durdur", width=200, fg_color="red", command=self.stop)
        self.stop_btn.pack(pady=5)

        self.stop_flag = threading.Event()

    def log(self, msg):
        """Log penceresine yaz"""
        timestamp = time.strftime("%H:%M:%S")
        self.log_text.configure(state="normal")
        self.log_text.insert("end", f"[{timestamp}] {msg}\n")
        self.log_text.see("end")
        self.log_text.configure(state="disabled")
        logging.info(msg)

    def start(self):
        self.stop_flag.clear()
        self.start_btn.configure(state="disabled")
        threading.Thread(target=self.run, daemon=True).start()

    def stop(self):
        self.stop_flag.set()
        self.log("=== İşlem durduruldu ===")
        self.start_btn.configure(state="normal")

    def run(self):
        try:
            self.check_update()
            if self.stop_flag.is_set():
                self.log("İşlem kullanıcı tarafından durduruldu. Oyun başlatılmayacak.")
                return
            self.launch_game()
        except Exception as e:
            self.log(f"HATA: {e}")
            self.start_btn.configure(state="normal")

    def check_update(self):
        self.log("GitHub ile bağlantı kontrol ediliyor...")
        if self.stop_flag.is_set(): return

        try:
            r = requests.get(VERSION_URL, timeout=15, verify=False)
            if r.status_code == 404:
                self.log("version.json bulunamadı. Fallback ZIP kullanılacak.")
                self.download(FALLBACK_ZIP, "1.0.0")
                return
            r.raise_for_status()
            data = r.json()
            remote_version = data.get("version", "1.0.0")
            zip_url = data.get("zip_url", FALLBACK_ZIP)
        except Exception as e:
            self.log(f"Versiyon alınamadı: {e}")
            self.download(FALLBACK_ZIP, "1.0.0")
            return

        local_version = "0.0.0"
        if os.path.exists(VERSION_FILE):
            with open(VERSION_FILE, "r") as f:
                local_version = f.read().strip()
        self.log(f"Yerel versiyon: {local_version}, Uzaktaki versiyon: {remote_version}")

        if remote_version != local_version:
            self.log("Yeni versiyon bulundu. İndiriliyor...")
            self.download(zip_url, remote_version)
        else:
            self.log("Oyun güncel. Kurulum gerekli değil.")

    def download(self, url, version):
        if self.stop_flag.is_set(): return

        self.log(f"Bağlantı kuruluyor: {url}")
        try:
            # allow_redirects=True ekledik ve stream başlattık
            r = requests.get(url, stream=True, timeout=60, verify=False, allow_redirects=True)
            
            # Bazı sunucular küçük harf kullanabilir veya hiç göndermeyebilir
            total = int(r.headers.get("content-length", r.headers.get("Content-Length", 0)))
            
            if total == 0:
                self.log("Uyarı: Dosya boyutu alınamadı, yüzde hesaplanamıyor...")

            chunk_size = 8192
            downloaded = 0
            data = io.BytesIO()

            for chunk in r.iter_content(chunk_size=chunk_size):
                if self.stop_flag.is_set():
                    self.log("İndirme durduruldu.")
                    return
                if chunk:
                    data.write(chunk)
                    downloaded += len(chunk)
                    
                    if total > 0:
                        percent = (downloaded / total) * 100
                        # Her chunk'ta log basmak yerine sadece tam sayılarda basarak kirliliği önleyebilirsin
                        self.log(f"İndiriliyor: {downloaded}/{total} byte ({percent:.1f}%)")
                    else:
                        self.log(f"İndiriliyor: {downloaded} byte (Toplam boyut bilinmiyor)")

            self.log("ZIP indirildi. Kurulum başlatılıyor...")
        self.log(f"ZIP indiriliyor: {url}")
        try:
            r = requests.get(url, stream=True, timeout=60, verify=False)
            total = int(r.headers.get("content-length", 0))
            chunk_size = 8192
            downloaded = 0
            data = io.BytesIO()

            for chunk in r.iter_content(chunk_size=chunk_size):
                if self.stop_flag.is_set():
                    self.log("İndirme durduruldu.")
                    return
                if chunk:
                    data.write(chunk)
                    downloaded += len(chunk)
                    percent = downloaded / total * 100 if total else 0
                    self.log(f"İndiriliyor: {downloaded}/{total} byte ({percent:.1f}%)")
            self.log("ZIP indirildi. Kurulum başlatılıyor...")
        except Exception as e:
            self.log(f"ZIP indirilemedi: {e}")
            raise

        # Eski oyun klasörünü temizle
        if os.path.exists(GAME_DIR):
            self.log(f"Eski oyun klasörü temizleniyor: {GAME_DIR}")
            shutil.rmtree(GAME_DIR, ignore_errors=True)
            time.sleep(0.5)
        os.makedirs(GAME_DIR, exist_ok=True)

        # ZIP aç
        if self.stop_flag.is_set(): return
        try:
            data.seek(0)
            with zipfile.ZipFile(data) as z:
                self.log("ZIP içeriği açılıyor...")
                z.extractall(GAME_DIR)
            self.log("Kurulum tamamlandı.")
        except Exception as e:
            self.log(f"ZIP açılamadı: {e}")
            raise

        # Versiyon dosyası yaz
        with open(VERSION_FILE, "w") as f:
            f.write(version)
        self.log(f"Versiyon kaydedildi: {version}")

    def find_python(self):
        import shutil
        py = shutil.which("python") or shutil.which("python3")
        if not py:
            raise RuntimeError("Python bulunamadı. Oyunu başlatmak için Python gerekli.")
        return py

    def launch_game(self):
        if self.stop_flag.is_set():
            self.log("Oyun başlatma iptal edildi.")
            return

        main_py = None
        for root, dirs, files in os.walk(GAME_DIR):
            if "main.py" in files:
                main_py = os.path.join(root, "main.py")
                break

        if not main_py:
            raise RuntimeError("main.py bulunamadı!")

        python = self.find_python()
        self.log(f"Oyun başlatılıyor: {main_py} (Python: {python})")

        try:
            subprocess.Popen([python, main_py], cwd=os.path.dirname(main_py))
            self.log("Oyun process başlatıldı.")
        except Exception as e:
            self.log(f"Oyun başlatılamadı: {e}")
            raise

        self.log("Launcher kapanıyor...")
        self.after(1000, self.destroy)


if __name__ == "__main__":
    Launcher().mainloop()
